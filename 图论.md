## (单源最短路)**spfa**
## [POJ1062 昂贵的聘礼]
- #### [题目连接](http://poj.org/problem?id=1062)
- #### [博客连接](https://www.cnblogs.com/JasonCow/p/14959809.html)
## 题目大意：
- 搜索到的最短路径中，阶级差不超过`m`
- 含有点权和边权

## **Sample Input**
```
1 4
10000 3 2
2 8000
3 5000
1000 2 1
4 200
3000 2 1
4 200
50 2 0
```
## **Sample Output**
```
5250
```

## 解题思路：
- 单源最短路(`spfa`)
- 枚举`m`种区间，并加入限制条件

## `加限制的spfa`
```cpp
#define ifIsUnderTheRestrictionOfLevel if(minLevel<=level[v]&&level[v]<=maxLevel)

void spfa(int n,int minLevel,int maxLevel){
    queue<int>q;
    fill(dis,dis+n+1,INF),fill(vis,vis+n+1,0);
    q.push(0),vis[0]=1,dis[0]=0;
    while(!q.empty()) {
        int u=q.front();q.pop(),vis[u]=0;
        for(int i=0;i<G[u].size();i++) {
            edge&e=G[u][i];
            int&v=e.v,w=e.w;
            ifIsUnderTheRestrictionOfLevel          //限制条件
            if (dis[v]>dis[u]+w) {
                dis[v]=dis[u]+w;
                if(!vis[v])q.push(v),vis[v]=1;
            }
        }
    }
}
```

## (传递闭包)Floyd+(二分图匹配)匈牙利算法
## [POJ1087 A Plug for UNIX]
- #### [题目连接](http://poj.org/problem?id=1087)
- #### [博客连接](https://www.cnblogs.com/JasonCow/p/14961148.html)

## 题目大意：
- 有电器和配套的插座，以及每种无限个的装换插头
- 问：最少多少电器用不上电？

## **Sample Input**
```
4 
A 
B 
C 
D 
5 
laptop B 
phone C 
pager B 
clock B 
comb X 
3 
B X 
X A 
X D
```
## **Sample Output**
```
1
```


## `dfs增广return bool`
```cpp
bool dfs(int u) {
    for(int i=1; i<=m; i++)
        if(!used[i]&&g[u][i]) {
            used[i]=1;
            if(match[i]==-1||dfs(match[i]))
                match[i]=u,
                return true;
        }
    return false;
}
```
## `匈牙利算法`
```cpp
int hungary() {
    int res=0;
    memset(match,-1,sizeof(match));
    for(int i=m+n+101; i<=m+n+101+n; res+=dfs(i++))
        memset(used,0,sizeof(used));
    return n-res;                       //此题问的是最少不能匹配，所以返回的是补集。
}
```

## (拓扑排序)**bfs**/(有向图找环)**floyd**
## [POJ1094 Sorting It All Out]
- #### [题目连接](http://poj.org/problem?id=1094)
- #### [博客连接](https://www.cnblogs.com/JasonCow/p/14961232.html)


## 题目大意
- 给出`m`个关于`n`个元素的偏序关系
- 问：如何排序？若不能从合适不能？或者不能确定偏序关系。
## **Sample Input**
```
4 6
A<B
A<C
B<C
C<D
B<D
A<B
3 2
A<B
B<A
26 1
A<Z
0 0
```
## **Sample Output**
```
Sorted sequence determined after 4 relations: ABCD.
Inconsistency found after 2 relations.
Sorted sequence cannot be determined.
```

## 解题思路
- **思路一：拓扑排序**
- **思路二：Floyd+判断**


## `拓扑排序`
```cpp
int map[27][27],indegree[27],q[27];
int TopoSort(int n){
    int t=0,temp[27],p,m,flag=1;  //flag=1:有序 flag=-1:不确定
    for(int i=1;i<=n;i++)temp[i]=indegree[i];
    for(int i=1;i<=n;i++){
        m=0;for(int j=1;j<=n;j++)if(temp[j]==0)m++,p=j;//查找入度为零的顶点个数
        if(m==0)return 0; //有环
        if(m>1) flag=-1;  //无序
        q[++t]=p,temp[p]=-1;//入度为零的点入队
        for(int j=1;j<=n;j++)if(map[p][j]==1)temp[j]--;
    }
    return flag;
}
```
## `floyd+判断`
```cpp
const int N=30;
int n, m, d[N][N], e[N][N];
int floyd() {
    memcpy(e, d, sizeof(e));
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                e[i][j] |= e[i][k] & e[k][j];
                if (e[i][j] == e[j][i] && e[i][j] && i != j) return -1; //成环了
            }
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            if (e[i][j] == e[j][i] && !e[i][j] && i != j) return 0;     //不确定
    return 1;//已经有序
}
```


